# 1. Two Sum
###题目
给定一个无序数组，求出数组中的两个下标，使得这两个下标对应数字之和等于target。题目保证只有一组可行解。
###思路1
直接对数组排序，会丢失下标信息， 所以构造struct数组保存每个数字的下标信息。对数组升序排序，从两头逼近。
时间复杂度:O(Nlong(N))
```
class Solution {
public:
    typedef struct node{
        int id;
        int num;
    }Node;
    static bool cmp(Node &a, Node &b){
        return a.num < b.num;
    }
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<Node> sortNums(nums.size());
        for(int i = 0; i < nums.size(); i++) {
            sortNums[i].id = i;
            sortNums[i].num = nums[i];
        }
        sort(sortNums.begin(), sortNums.end(), cmp);
        vector<int> res;
        int i = 0, j = (int)sortNums.size() - 1;
        while(i < j){
            int sum = sortNums[i].num + sortNums[j].num;
            if(sum == target) {
                res.push_back(min(sortNums[i].id, sortNums[j].id));
                res.push_back(max(sortNums[i].id, sortNums[j].id));
                return res;
            }
            else if(sum > target) --j;
            else ++i;
        }
        return res;
    }
};
```
###思路2
构造`map<int, int> id`用于记录数组中每个数字和它的下标的对应关系。从左到右扫描一遍数组，判断当前数的对偶数(数字a的对偶数：target-a)是否在id中：不在，则加入到id中；在则输出结果。这种做法的聪明之处在于，把每次已经遇到过的数字记录下来。当遇到解的第二个数字的时候，正好输出结果。
时间复杂度:O(log(N)) 
```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> map;
        vector<int> res;
        for (int i = 0; i < nums.size(); i++) {
            int numToFind = target - nums[i];
            // 先写找到的情况，因为找到了直接return，下面一段代码就不用写else，更简洁
            if (map.count(numToFind) != 0) {
                res.push_back(map[numToFind]);
                res.push_back(i);
                return res;
            }
            map[nums[i]] = i;
        }
        return res;
    }
};
```
