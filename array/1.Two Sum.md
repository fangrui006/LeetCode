# 1. Two Sum
###题目
给定一个无序数组，求出数组中的两个下标，使得这两个下标对应数字之和等于target。题目保证只有一组可行解。
###思路
构造`map<int, int> id`用于记录数组中每个数字和它的下标的对应关系。从左到右扫描一遍数组，判断当前数的对偶数(数字a的对偶数：target-a)是否在id中：不在，则加入到id中；在则输出结果。这种做法的聪明之处在于，把每次已经遇到过的数字记录下来。当遇到解的第二个数字的时候，正好输出结果。
时间复杂度:O(log(N)) 
```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> map;
        vector<int> res;
        for (int i = 0; i < nums.size(); i++) {
            int numToFind = target - nums[i];
            // 先写找到的情况，因为找到了直接return，下面一段代码就不用写else，更简洁
            if (map.count(numToFind) != 0) {
                res.push_back(map[numToFind]);
                res.push_back(i);
                return res;
            }
            map[nums[i]] = i;
        }
        return res;
    }
};
```
