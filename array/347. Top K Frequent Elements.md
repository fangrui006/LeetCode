#347. Top K Frequent Elements
###题目
找出前k个频繁的数，不要求结果有序，要求时间复杂度小于O(Nlog(N))
###思路
使用unordered_map是避免map中的红黑树的实现方法（创建N个元素的map的时间复杂度是O(Nlog(N))）。
unordered_map时间复杂度是O(1)常数级别。
假设map中有10个数，我们要找前3频繁的数，我们只需要建立一个size是7的大根堆（优先级队列），当size>7时，输出top元素。即得到结果。
时间复杂度: O(n log(n-k))
```
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
       unordered_map<int, int> m;
       for (int i = 0; i < nums.size(); i++) {
           m[nums[i]]++;
       }
       vector<int> res;
       priority_queue< pair<int, int> > pq;
       for (auto it = m.begin(); it != m.end(); ++it) {   //m.end()
           pq.push(make_pair(it->second, it->first));
           if (pq.size() > (int)m.size() - k) {
              res.push_back(pq.top().second);
              pq.pop();
           }
       }
       return res;
    }
};
```
