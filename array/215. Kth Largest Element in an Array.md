#215. Kth Largest Element in an Array
###题目
求无序数组第K大的数
###思路1
quickSort思想
时间复杂度：
最好情况O(N)（一次排序完成）
最差情况O(N^2)（完全升序排列的数组）
```
class Solution {
public:
    int partition(vector<int>& nums, int low, int high) {
        int pivotkey = nums[low];
        int i = low, j = high;
        while (i < j) {
            while (i < j && nums[j] >= pivotkey) --j;
            if (i < j) nums[i++] = nums[j];
            else
                break;
            while (i < j && nums[i] <= pivotkey) ++i;
            if (i < j) nums[j--] = nums[i];
            else
                break;
        }
        nums[i] = pivotkey;
        return i;
    }
    int findKthLargest(vector<int>& nums, int k) {
        int low = 0;
        int high = nums.size()-1;
        while (true) {
            int pivot = partition(nums, low, high);
            if (pivot == nums.size()-k) {
                return nums[pivot];
            } else if (pivot > nums.size()-k) {
                high = pivot-1;
            } else {
                low = pivot+1;
            }
        }
    }
};
```
###思路2
堆排序思想：先建立大顶堆（`nums[0]`是最大的数）。只要把堆的第0位与`heap_size-1`位交换，`heap_size`减1，`heapify`第0位，就能保证`nums[0]`就是第二大的数，此过程重复k-1次，就能得到第k大的数`nums[0]`。
时间复杂度：？？？
```C++
class Solution {
public:
    inline int left(int i) {
        return (i << 1) + 1;
    }
    inline int right(int i) {
        return (i << 1) + 2;
    }
    void max_heapify(vector<int>& nums, int idx) {
        int largest = idx;
        while (largest < heap_size) {
            int l = left(largest);
            int r = right(largest);
            int t = largest;
            if (l < heap_size && nums[t] < nums[l]) t = l;
            if (r < heap_size && nums[t] < nums[r]) t = r;
            if (t == largest) {
                return;
            } else {
                swap(nums[t], nums[largest]);
                largest = t;
            }
        }
    }
    void build_maxheap(vector<int>& nums) {
        heap_size = nums.size();
        for (int i = (heap_size >> 1) - 1; i >= 0; --i) {
            max_heapify(nums, i);
        }
    }
    int findKthLargest(vector<int>& nums, int k) {
        build_maxheap(nums);
        for (int i = 0; i < k - 1; i++) {
            swap(nums[0], nums[heap_size - 1]);
            --heap_size;
            max_heapify(nums, 0);
        }
        return nums[0];
    }

private:
    int heap_size;
};
```
###思路3
优先级队列:默认的优先级队列实际上就是建立了一个大顶堆，每次pop都会把根节点删除并调整堆，使得根节点变成第二大的数。
时间复杂度：O(log(N))
```
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int> pq(nums.begin(), nums.end());
        for (int i = 0; i < k - 1; i++) {
            pq.pop();
        }
        return pq.top();
    }
};
```
###思路4
multiset：实际上也是大顶堆的组织形式
```
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        multiset<int> ms;
        for (int i = 0; i < nums.size(); i++) {
            ms.insert(nums[i]);
            if (ms.size() > k)
                ms.erase(ms.begin());
        }
        return *ms.begin();
    }
};
```
erase的三种重载函数：
>   iterator erase(iterator it):删除迭代器指针it处元素

    iterator erase(iterator first,iterator last):删除[first, last)之间元素

    size_type erase(const Key& key):删除元素值等于key的元素

###coding style
1. if/while/for关键字后面空一格；
2. 如果if有花括号，那么else应该接在if的}后面，而不能另起一行（}后面也要空一格）；
3. 如果else后面只有一句，那么这一句不能与else同行，而应该另起一行;
4.private与上面的代码段应该留一行空白行。
