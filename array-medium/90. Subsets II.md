#90. Subsets II
###题目

给定一个整数集合，可能包含重复元素，返回它所有可能的子集。结果集合中不能包含重复的子集。

比如，给定集合[1, 2, 2]，应当返回

```
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
```

###思路
回溯：用map记录每个元素出现的次数，由于`map`的构造的时候是有序的，所以按顺序输出到`list`数组中也是有序的。


回溯的时候，当前是cur，搜索空间就是从cur开始到最后一个元素。遍历搜索空间，每次选取一个元素加入，写入最终结果，继续深搜。回溯后，选取搜索空间的下一个元素。


```
class Solution {
private:
    vector<pair<int, int>> list;
    vector<int> sol;
    vector<vector<int>> res;
    void backtrack(int cur) {
        for (int i = cur; i < list.size(); i++) {
            if (list[i].second > 0) {
                sol.push_back(list[i].first);
                res.push_back(sol);
                list[i].second--;
                backtrack(i);
                sol.pop_back();
                list[i].second++;
            }
        }
    }
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        map<int, int> count;
        for (int i = 0; i < nums.size(); i++)
            count[nums[i]]++;
        for (auto x: count)
            list.push_back(make_pair(x.first, x.second));
        res.push_back(vector<int>(0));
        backtrack(0);
        return res;
    }
};
```
