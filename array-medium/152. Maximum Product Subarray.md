#152. Maximum Product Subarray
###题目

找出一段连续的子数组，使得它们的乘积最大，返回最大乘积

例如，数组[2, 3, -2, 4]，有最大乘积子数组[2, 3]，返回6。

###思路
[参考](http://www.cnblogs.com/bakari/p/4007368.html)

动态规划：如果是求和的最大子数组，我们知道

`dp[i+1] = max(dp[i] + nums[i], nums[i])`

但是乘积有负数，两个很小的负数相乘可以得到很大的负数。所以需要同时维护一个局部最小值和一个局部最大值
 - 局部最小或最大指的是以当前数作为结尾的子数组的最小乘积，最大乘积
 
可以举例[-2, -3, -7]和[-2, 3, 7]。

```
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int localMin = nums[0], localMax = nums[0], globalMax = nums[0];
        for (int i = 1; i < nums.size(); i++) {
            int tmp1 = max(max(nums[i], nums[i] * localMax), nums[i] * localMin);
            int tmp2 = min(min(nums[i], nums[i] * localMax), nums[i] * localMin);
            localMax = tmp1;
            localMin = tmp2;
            globalMax = max(localMax, globalMax);
        }
        return globalMax;
    }
};
```
