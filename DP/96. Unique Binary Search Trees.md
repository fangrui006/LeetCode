# 96. Unique Binary Search Trees
## 题目

给定n，请问有多少种存储着1~n中所有数的结构独特的二叉搜索树。

```
比如，给定n=3，一共有5种独特的二叉搜索树
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

## 思路

如果二叉搜索树包含的数字从1~n，根据二叉搜索树的性质“中序遍历的结果是升序的”可知，中序遍历的结果是1 2 3 4 ... n。

那么我们任选一个节点编号x作为root，root左子树[1 2 ... x-1]和右子树[x＋1 x+2 ... n]都是升序的子序列。我们只需要确定左子树和右子树各自有多少种独特的形态，就可以求出n个节点一共有多少种形态，那么问题划分成了规模更小的子问题，由此：

1. 状态划分

dp[j]：表示j个升序的整数序列可以组成的独特的BST树的个数。

target:dp[n]

2. 状态转移方程。

如何求解dp[j]？

给定j个升序排列的数（中序遍历的结果），我们任选一个数x作为root，划分成的左子树是x-1个数组成的升序子序列，右子树是j-x个数组成的升序子序列。

那么对于这种划分，组合而成的独特BST树的种类数就是dp[x-1]*dp[j-x]。

我们知道x可以从1~j中任意选择，所以最终`dp[j] = dp[j-1] + dp[1]*dp[j-2] + dp[2]*dp[j-3] + ... + dp[j-2]*dp[1] + dp[j-1]`。

3. 初始状态确定

为了方便用迭代的方式计算dp[j]，我们令dp[0] = 1，那么有`dp[j] = dp[0]*dp[j-1] + dp[1]*dp[j-2] + dp[2]*dp[j-3] + ... + dp[j-2]*dp[1] + dp[j-1]*dp[0]`

所以有dp[0] = 1；易得，dp[1]=1

```C++
class Solution {
public:
    int numTrees(int n) {
        if (n <= 0) return 0;
        vector<int> dp(n + 1);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++)
            for (int j = 0; j <= i - 1; j++)
                dp[i] += dp[j] * dp[i - 1 - j];
        return dp[n];
    }
};
```
