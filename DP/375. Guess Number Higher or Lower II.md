# 375. Guess Number Higher or Lower II
## 题目
我们现在玩一个猜数游戏。游戏如下：

我从1到n中选择一个数字，你来猜出我选的数字是什么。

如果你猜错了，我会告诉你我选的数字更大还是更小。

当你猜错的时候，假设你选择的数字是x，你会被惩罚x个金币。当你猜对我选择的数字，你就赢了游戏。

现在给定一个n（n >= 1），为了保证赢得游戏，请问你需要准备多少金币？

## 思路
动态规划。

dp[i][j]：表示在范围[i, j]中猜对结果，最少需要准备的金币数。考虑至少要准备的金币数，那就要考虑最坏情况：也就是只要区间长度不等于1，那么每次取的数字都不对。

target：dp[1][n]

如何求dp[i][j]：如果我们从[i~j]之间任选一个数k。那么k不是最终结果，区间[i~j]被划分为区间[i, k-1]和区间[k+1, j]，原问题被划分成两个子问题，dp[i][k-1]和dp[k+1][j]。最终我们选择最坏的结果，就是子问题中取值最大的一个。如果我们准备的金币足够应对取值较大的区间，那么也能应付取值较小的区间。

这是任选一个k的结果，最终我们要在所有的结果中选择取值最小的一个，就是在区间[i~j]之间最少需要准备的金币数。

dp[i][j] =  min {k + max{dp[i][k-1], dp[k+1][j]}}, i <= k <= j

```C++
class Solution {
public:
    int getMoneyAmount(int n) {
        if (n <= 1) return 0;
        vector<vector<int> > dp(n + 1, vector<int>(n + 1));
        for (int d = 1; d <= n - 1; d++) {
            for (int i = 1; i <= n && i + d <= n; i++) {
                int l = i, r = i + d;
                dp[l][r] = r + dp[l][r - 1];
                for (int j = r - 1; j >= l; j--) {
                    int local = j + max(dp[l][j - 1], dp[j + 1][r]);
                    dp[l][r] = min(dp[l][r], local);
                }
            }
        }
        return dp[1][n];
    }
};
```
