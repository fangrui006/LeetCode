# 264. Ugly Number II
## 题目

找出第n个丑数。丑数定义：质因子只包含2,3和5的正整数。比如，前10个丑数是1, 2, 3, 4, 5, 6, 8, 9, 10, 12。

特别地，1作为第一个丑数。

## 思路

丑数：

 | factor \ uglynum | 1 | 2 | 3 | 4 | 5 |
 | -------------- | --- | --- | --- | --- | --- |
 | 2* | 2*1 | 2*2 | 2*3 | 2*4 | 2*5 | 
 | 3* | 3*1 | 3*2 | 3*3 | 3*4 | 3*5 |
 | 5* | 5*1 | 5*2 | 5*3 | 5*4 | 5*5 | 
 
如上表格，第一行表示丑数，第一列表示因子，表格内的每个cell表示丑数与因子的乘积。只要表格的列足够大，表格内的所有cell就可以代表所有丑数，关键是如何按照升序依次取出每个丑数（同时注意去重）。问题转变成给定三个升序的数组，如何依次取出最小的数。按照归并排序的思想即可解。给定三个指针，依次指向三个数组最小的数。每一次比较三个指针得出全局最小的数，对应的指针往前走一步（可能多个最小的数，那么对应的指针都要往前走一步）。

```C++
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> dp(n);
        dp[0] = 1;
        int t2 = 0, t3 = 0, t5 = 0;
        for (int i = 1; i < n; i++) {
            dp[i] = min(dp[t2] * 2, min(dp[t3] * 3, dp[t5] * 5));
            if (dp[i] == dp[t2] * 2) t2++;
            if (dp[i] == dp[t3] * 3) t3++;
            if (dp[i] == dp[t5] * 5) t5++;
        }
        return dp[n - 1];
    }
};
```
