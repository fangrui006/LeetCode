# 392. Is Subsequence
## 题目

给定一个字符串s和一个字符串t，检查s是不是t的子序列。字符串中只包含小写英文字母，t是一个非常长（长度 ~= 500,000）的字符串，s是一个短串（长度<=100）。

如果我们从t中删除一些字符，剩下的字符按顺序能够组成s，我们就说s是t的子序列。

```
Example 1:
s = "abc", t = "ahbgdc"
Return true.

Example 2:
s = "axc", t = "ahbgdc"
Return false.
```

Follow up:
如果有很多的候选S，比如说s1, s2, s3, ..., sk（k >= 1B），你想要依次检查他们是不是t的子序列。这种场景下，如何改变你的代码。

## 思路

指针i和j，分别指向s和t的首位。依次比较s[i]和t[j]是否相等，如果相等，i和j同时往前移动一位；否则，j往前移动一位

```C++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int i = 0, j = 0;
        while (i < s.size() && j < t.size()) {
            if (s[i] == t[j]) {
                i++;
            }
            j++;
        }
        return i == s.size();
    }
};
```

## follow up
1. 二分查找

对于t中出现的每个字符建立索引。那么一个字符对应一个升序的vector，vector中存储该字符在t中出现位置的下标。
给定一个串s，我们查找s[i]在t中的位置记为ti，那么s[i+1]在t中出现的位置必须大于ti。所以对于s[i+1]对应的升序vector，我们需要从中找到第一个大于ti的数。所以可以用二分查找。

2. trie树

如果我们已经验证过s1是t的子序列。现在又来了一个字符串s2，并且s1是s2的前缀串，s1 = s2.substr(0, i-1)。那么我们接下来只需要从s2(i)开始验证即可。所以对于每个已经验证过的子串，我们都加入到trie树中，树的每个结点都记录该字符对应t中的下标。现在来了一个字符串s，我们从trie树中找出最长前缀串。假设该串最后一个字符是x，对应t中的下标是j，那么接下来我们从s(x+1)开始，寻找t中s(x+1)字符出现的下标大于j的位置。

两种方法综合起来，可以加快查询。
